
	/*
	 * receive communicate from server about existing file or not
	 */
	while(work)
	{
	      /* top from queue */
	      fprintf(stderr, "Waiting to receive DOWNLOADRESPONSE \n");
	      if (top(queue, message) < 0)
	      {
		fprintf(stderr, "Queue is empty, nothing to show \n");
		sleep(2);
		message = calloc(CHUNKSIZE, sizeof(char));
		continue;
	      }
	      task = check_message_type(message);
	      fprintf(stderr, "Real task nummber %d \n", (int)task);
	      if(task == ERROR)
	      {
		get_filename_from_message(message, error_file_path);
		fprintf(stderr, "Got task with type ERROR for filename %s \n", error_file_path);
		continue;
	      }
	      if(task != DOWNLOADRESPONSE)
	      {
		/* push to the end of queue */
		fprintf(stderr, "Task type is not DOWNLOADRESPONSE\n");
		push(queue, message);
		sleep(1);
		continue;
	      }
	      /* waiting for confirmation or rejection of downloading file*/
	      else if(id == -1)
	      {
		
		/* check the filepath saved in message*/
		get_filename_from_message(message, filepath);
		for(i = 0; i < FILENAME; i++)
		{
		    if(filepath[i] != oldFilePath[i])
		    {
		      fprintf(stderr, "Not this message, wrong filepath \n");
		      push(queue, message);
		      break;
		    }
		}
		/* filepaths are the same */
		if(i == FILENAME)
		{
		  /* check if id > 0 else show error got from server */
		  tmpid = get_id_from_message(message);
		  strcpy(communicate, message + 3 * sizeof(uint32_t)/ sizeof(char) + FILENAME);
		  if(tmpid == 0)
		  {
		    /* error with file , show message */
		    fprintf(stdout, "Could not download file %s, reason : %s \n", filepath, communicate);
		    push(queue, message);
		    pthread_exit(&targ);
		    return NULL;
		  }
		  else
		  {
		    id = tmpid;
		    fprintf(stdout, "Server confirmed downloading file  %s, \n  message : %s \n", filepath, communicate);
		    fprintf(stdout, "Got id %d \n", id);
		    /* check if file exists if not create else check if is opened if not remove data and write own */
		    for(i = 0; i < FILENAME; i++)
		    {
			if(filepath[i] == '\0' || filepath[i] == '\n')
			{
			  first_empty_sign = i;
			  break;
			}
		    }
		    fprintf(stderr, "Empty sign found at position : %d \n", first_empty_sign);
		    real_file_name = calloc(first_empty_sign , sizeof(char));
		    for(i = 0; i < first_empty_sign; i++)
		    {
			real_file_name[i] = filepath[i];
		    }
		    fprintf(stderr, "Real file name size %zu after malloc \n", strlen(real_file_name));
		    if(open(real_file_name, O_RDWR) < 0)
		    {
			  fd = open(real_file_name, O_RDWR | O_CREAT, S_IRWXU | S_IRGRP | S_IROTH);
			  
			  fprintf(stderr, "Creating new file \n");
			  filesize = get_file_size_from_message(message);
			  buf = calloc(filesize, sizeof(char));
			  for(i = 0; i< filesize; i++)
			    buf[i] = '0';
			  bulk_write(fd, buf, filesize);
			  if(filesize == filesize / real_package_size * real_package_size)
			    package_amount = filesize / real_package_size;
			  else 
			      package_amount = filesize / real_package_size + 1;	
		    }
		    else
		    {
			 fprintf(stdout, "File already exists!\n");
			 /* remove unnecessary messages */
			 pthread_exit(&targ);
			 return NULL;
		    }
		    break;
		  }
		}
	      }
	}
	
	fprintf(stderr, "Waiting for datagrams with file content\n");

	while(work)
	{
	      fprintf(stderr, "Waiting to receive DOWNLOAD \n");
	      if (top(queue, message) < 0)
	      {
		fprintf(stderr, "Queue is empty, nothing to show \n");
		sleep(2);
		message = calloc(CHUNKSIZE, sizeof(char));
		continue;
	      }
	      task = check_message_type(message);
	      fprintf(stderr, "Real task nummber %d \n", (int)task);
	      if(task == ERROR)
	      {
		get_filename_from_message(message, error_file_path);
		fprintf(stderr, "Got task with type ERROR for filename %s \n", error_file_path);
		continue;
	      }
	      if(task != DOWNLOAD)
	      {
		/* push to the end of queue */
		fprintf(stderr, "Task type is not DOWNLOAD\n");
		push(queue, message);
		sleep(1);
		continue;
	      }
	      else
	      {
		  tmpid = get_id_from_message(message);
		  if(tmpid == id)
		  {
		      /*one of datagrams from servers*/
		      fprintf(stderr, "Id of message and thread are the same \n");
		      fprintf(stderr, "Got data for update \n");
		      package_number = get_file_size_from_message(message);
		      if(package_number == package_amount)
		      {
			fprintf(stderr, "Checking md5 sums \n");
			file_contents = read_whole_file (real_file_name);
			  if(file_contents == NULL) 
			  {
			    free (file_contents);
			    free(real_file_name);
			    free(package);
			    return NULL;
			  }
			compute_md5(file_contents, md5_sum);
			strcpy(package, message + 3 * sizeof(uint32_t)/sizeof(char) + FILENAME);
			for(i = 0; i< MD5LENGTH; i++)
			{
			  if(md5_sum[i] != package[i])
			  {
			    fprintf(stdout, "Wrong md5 sum %s \n", real_file_name);
			    return NULL;
			  }
			}		
		      }
		      else
		      {
			fprintf(stderr, "Write data to update file \n");
			strcpy(package, message + 3 * sizeof(uint32_t)/sizeof(char) + FILENAME);
			if ((fd = TEMP_FAILURE_RETRY(open(real_file_name, O_RDWR))) == -1)
			{
			  fprintf(stderr, "Could not open file \n");
			  return NULL;
			}
			/*if (stat(real_file_name, &sts) != -1)
			{
			  switch(errno)
			  {
			    case EACCES:
			      fprintf(stderr, "Permission denied for file %s \n", real_file_name);
			      break;
			    case EBADF:
			      fprintf(stderr, "File descriptor is bad for file %s \n", real_file_name);
			      break;
			    case EFAULT:
			      fprintf(stderr, "Bad address for file %s \n", real_file_name);
			      break;
			    case ELOOP:
			      fprintf(stderr, "Too many symbolic links encountered while traversing the path %s \n", real_file_name);
			      break;
			    case ENAMETOOLONG:
			      fprintf(stderr, "Path %s is too long \n", real_file_name);
			      break;
			    case ENOENT:
			      fprintf(stderr, "Length of file name %s is %zu \n", real_file_name, strlen(real_file_name));
			      fprintf(stderr, "A component of path %s does not exist, or path is an empty string \n", real_file_name);
			      break;
			    case ENOMEM:
			      fprintf(stderr, "Out of memory for file %s \n", real_file_name);
			      break;
			    case ENOTDIR:
			      fprintf(stderr, "A component of the path prefix of path %s is not a directory\n", real_file_name);
			      break;
			    case EOVERFLOW:
			      fprintf(stderr, "path or fd refers to a file %s whose size, inode number, or number of blocks cannot be represented in, respectively, the types off_t, ino_t, or blkcnt_t\n", real_file_name);
			      break;
			    default:
			      fprintf(stderr, "Uknonw error while trying to open file %s \n", real_file_name);
			      break;      
			  }
			  fprintf(stderr, "Could not open file %s \n", real_file_name);
			  return NULL;
			}*/
			/*file = fdopen(fd, "rw");
			if(file == NULL)
			{
			  if(errno == EINVAL)
			  {
			    fprintf(stderr, "Wrong mode of oppening file \n");
			  }
			  return NULL;
			}*/
			fprintf(stderr, "Package number %d \n", package_number);
			if(lseek(fd, package_number * real_package_size, SEEK_SET) < 0)
			{
			  fprintf(stderr, "Could not write.\n");
			}
			for(i = 0; i < strlen(package); i++)
			{
			  fprintf(stderr, "Package contains at position %d char %c \n", i, package[i]);
			}
			bulk_write(fd, package, strlen(package));
			fprintf(stderr, "Package was written to file %s \n", real_file_name);
			close(fd);
		      }
		  }
		  else
		  {
		    fprintf(stderr, "Pushing message back to queue \n");
		    push(queue, message);
		  }
	      }
	  }
